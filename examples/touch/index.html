<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Modest Maps JS - Touch Tester</title>
<script type="text/javascript" src="underscore-min.js"></script>
<script type="text/javascript" src="../../modestmaps.js"></script>
<script type="text/javascript">

function stderr(msg)
{
    req = new XMLHttpRequest();
    req.open('POST', 'trace.php', false);
    req.send(msg);
}

(function(MM){

    var maxTapDistance = 10,
    
    function distance(t1, t2)
    {
        return Math.sqrt(Math.pow(t1.screenX - t2.screenX, 2) + Math.pow(t1.screenY - t2.screenY, 2));
    }
    
    function Start(touch, time)
    {
        this.screenX = touch.screenX;
        this.screenY = touch.screenY;

        this.touch = touch;
        this.time = time;
        
        // the pointer chase ends here
        this.start = this;
        this.count = 0;
        this.travel = 0;
        this.last = null;
    }
    
    function Move(touch, last, time)
    {
        moved = distance(touch, last);
        
        this.screenX = touch.screenX;
        this.screenY = touch.screenY;
        
        this.touch = touch;
        this.time = time;

        // pointer chase
        this.start = last.start;
        this.count = last.count + 1;
        this.travel = last.travel + moved;
        this.last = last;
    }
    
    function Tap(x, y, time)
    {
        this.x = x;
        this.y = y;
        this.time = time;
    }
    
    function Hold(x, y, end, duration)
    {
        this.x = x;
        this.y = y;
        this.end = end;
        this.duration = duration;
    }
    
    function hasattr(obj, attr)
    {
        return _.any(_.keys(obj), function(key) { return key == attr });
    }
    
    function sameTouch(event, touch)
    {
        if(typeof event == 'object' && hasattr(event, 'touch'))
        {
            return touch == event.touch;
        }
    }
    
    function interruptTouches(events)
    {
        var now = new Date().getTime();

        for(var i = 0; i < events.length; i += 1)
        {
            var touch = events[i].touch;
            var start = new Start(touch, now);
            
            events[i] = start;
        }
    }
    
    function oneTouchMatrix(touch)
    {
        var start = touch.start;

        var x = touch.screenX - start.screenX;
        var y = touch.screenY - start.screenY;
        
        return [1, 0, 0, 1, x, y];
    }
    
    function twoTouchMatrix(t1, t2)
    {
        var t1_ = t1.start;
        var t2_ = t2.start;
        
        var span = distance(t1, t2);
        var span_ = distance(t1_, t2_);
        
        var s = span / span_;
        
        var x = (t1.screenX + t2.screenX) / 2;
        var y = (t1.screenY + t2.screenY) / 2;
        var x_ = (t1_.screenX + t2_.screenX) / 2;
        var y_ = (t1_.screenY + t2_.screenY) / 2;
        
        var tx = s * -x_ + x;
        var ty = s * -y_ + y;
        
        return [s, 0, 0, s, tx, ty];
    }
    
    MM.TouchHandler = function() { }

    MM.TouchHandler.prototype = {

        init: function(map) {
            this.map = map;
            /*
            MM.addEvent(map.parent, 'touchstart', this.getDoubleTap());
            MM.addEvent(map.parent, 'touchstart', this.getTouchStart());
            MM.addEvent(map.parent, 'gesturestart', this.getGestureStart());            
            */

            MM.addEvent(map.parent, 'touchstart', this.getTouchStartLog());
            MM.addEvent(map.parent, 'touchmove', this.getTouchMoveLog());
            MM.addEvent(map.parent, 'touchend', this.getTouchEndLog());

            MM.addEvent(map.parent, 'touchstart', this.getTouchStartMachine());
            MM.addEvent(map.parent, 'touchmove', this.getTouchMoveMachine());
            MM.addEvent(map.parent, 'touchend', this.getTouchEndMachine());
        },

        getTouchStartLogHandler: null,
        
        getTouchStartLog: function() {
            if (!this.getTouchStartLogHandler) {
                var theHandler = this;
                this.getTouchStartLogHandler = function(e)
                {
                    points = _.map(e.changedTouches, function(t) { return '(#' + t.identifier + ': ' + t.screenX + ', ' + t.screenY + ')'; }).join(', ');
                    stderr('                                touch start: ' + e.changedTouches.length + '/' + e.touches.length + ', ' + points);
                }
            }
            return this.getTouchStartLogHandler;
        },
        
        getTouchStartLogHandler: null,
        
        getTouchMoveLog: function() {
            if (!this.getTouchMoveLogHandler) {
                var theHandler = this;
                this.getTouchMoveLogHandler = function(e)
                {
                    //stderr('touch move');
                }
            }
            return this.getTouchMoveLogHandler;
        },
        
        getTouchEndLogHandler: null,
        
        getTouchEndLog: function() {
            if (!this.getTouchEndLogHandler) {
                var theHandler = this;
                this.getTouchEndLogHandler = function(e)
                {
                    points = _.map(e.changedTouches, function(t) { return '(#' + t.identifier + ': ' + t.screenX + ', ' + t.screenY + ')'; }).join(', ');
                    stderr('                                touch end: ' + e.changedTouches.length + '/' + e.touches.length + ', ' + points);
                }
            }
            return this.getTouchEndLogHandler;
        },
        
        maxTapTime: 150,
        maxTapDistance: 10,
        maxDoubleTapDelay: 350,
        events: [],
        taps: [],
        
        getTouchStartMachineHandler: null,
        
        getTouchStartMachine: function() {
            if (!this.getTouchStartMachineHandler) {
                var theHandler = this;
                var events = this.events;

                this.getTouchStartMachineHandler = function(e)
                {
                    interruptTouches(events);
                    
                    for(var i = 0; i < e.changedTouches.length; i += 1)
                    {
                        var touch = e.changedTouches[i];
                        var start = new Start(touch, new Date().getTime());

                        events.push(start);
                    }

                    return MM.cancelEvent(e);
                }
            }
            return this.getTouchStartMachineHandler;
        },
        
        getTouchStartMachineHandler: null,
        
        getTouchMoveMachine: function() {
            if (!this.getTouchMoveMachineHandler) {
                var theHandler = this;
                var events = this.events;

                this.getTouchMoveMachineHandler = function(e)
                {
                    var now = new Date().getTime();

                   /**
                    * Look at each changed touch in turn.
                    */
                    for(var i = 0; i < e.changedTouches.length; i += 1)
                    {
                        var touch = e.changedTouches[i];
                        
                        for(var j = 0; j < events.length; j += 1)
                        {
                            if(sameTouch(events[j], touch))
                            {
                                events[j] = new Move(touch, events[j], now);
                            }
                        }
                    }
                    
                    if(events.length == 1) {
                        theHandler.onPanning(events[0]);

                    } else if(events.length == 2) {
                        theHandler.onPinching(events[0], events[1]);
                    }

                    return MM.cancelEvent(e);
                }
            }
            return this.getTouchMoveMachineHandler;
        },
        
        getTouchEndMachineHandler: null,
        
        getTouchEndMachine: function() {
            if (!this.getTouchEndMachineHandler) {
                var theHandler = this;
                var events = this.events;

                this.getTouchEndMachineHandler = function(e)
                {
                    var now = new Date().getTime();
                    
                    if(events.length == 1) {
                        theHandler.onPanned(events[0]);

                    } else if(events.length == 2) {
                        theHandler.onPinched(events[0], events[1]);
                    }

                   /**
                    * Look at each changed touch in turn.
                    */
                    for(var i = 0; i < e.changedTouches.length; i += 1)
                    {
                        var touch = e.changedTouches[i];
                        
                        for(var j = 0; j < events.length; j += 1)
                        {
                            if(sameTouch(events[j], touch))
                            {
                                var event = new Move(touch, events[j], now);
                                
                                stderr('End of the line for touch #' + touch.identifier + ', c=' + event.count + ', ' + (now - event.start.time) + 'ms, ' + event.travel.toFixed(0) + 'px');
                                events.splice(j, 1);
                                j -= 1;
                                
                                // we now know we have an event object and a
                                // matching touch that's just ended. Let's see
                                // what kind of event it is based on how long it
                                // lasted and how far it moved.
                            
                                var time = now - event.start.time;
                                
                                if(event.travel > theHandler.maxTapDistance) {
                                    // we will to assume that the drag has been handled separately
                                
                                } else if(time > theHandler.maxTapTime) {
                                    // close in time, but not in space: a hold
                                    var hold = new Hold(touch.screenX, touch.screenY, now, time);
                                    theHandler.onHold(hold);
                                
                                } else {
                                    // close in both time and space: a tap
                                    var tap = new Tap(touch.screenX, touch.screenY, now);
                                    theHandler.onTap(tap);
                                }
                            }
                        }
                    }
                    
                    interruptTouches(events);
                    
                    if(e.touches.length == 0 && events.length >= 1)
                    {
                        // Weird, sometimes an end event doesn't get thrown
                        // for a touch that nevertheless has disappeared.
                        events.splice(0, events.length);
                    }
                    
                    return MM.cancelEvent(e);
                }
            }
            return this.getTouchEndMachineHandler;
        },
        
        onHold: function(hold)
        {
            stderr('Hold: (' + hold.x + ', ' + hold.y + ') for ' + hold.duration + ' msec');
        },
        
        onTap: function(tap)
        {
            if(this.taps.length && (tap.time - this.taps[0].time) < this.maxDoubleTapDelay)
            {
                this.onDoubleTap(tap);
                return;
            }
            
            stderr('Tap: (' + tap.x + ', ' + tap.y + ')');
            
            this.taps = [tap];
        },
        
        onDoubleTap: function(tap)
        {
            stderr('Double-tap: (' + tap.x + ', ' + tap.y + ')');
            
            // zoom in to a round number
            var z = Math.floor(this.map.getZoom() + 2);
            z = z - this.map.getZoom();

            var p = new MM.Point(tap.x, tap.y);
            
            this.map.zoomByAbout(z, p);
        },
        
        onPanning: function(touch)
        {
            var m = oneTouchMatrix(touch);
            m = ['1', '0', '0', '1', m[4].toFixed(0), m[5].toFixed(0)];
            m = 'matrix(' + m.join(', ') + ')';
            
            this.map.parent.style.webkitTransformOrigin = '0px 0px';
            this.map.parent.style.webkitTransform = m;
        },
        
        onPanned: function(touch)
        {
            var m = oneTouchMatrix(touch);

            stderr('Pan by ' + m[4].toFixed(0) + ', ' + m[5].toFixed(0));

            this.map.panBy(m[4], m[5]);
            this.map.parent.style.webkitTransform = '';
        },
        
        onPinching: function(touch1, touch2)
        {
            var m = twoTouchMatrix(touch1, touch2);
            m = [m[0].toFixed(3), '0', '0', m[3].toFixed(3), m[4].toFixed(0), m[5].toFixed(0)];
            m = 'matrix(' + m.join(', ') + ')';
            
            this.map.parent.style.webkitTransformOrigin = '0px 0px';
            this.map.parent.style.webkitTransform = m;
        },
        
        onPinched: function(touch1, touch2)
        {
            var m = twoTouchMatrix(touch1, touch2);
            var z = Math.log(m[0]) / Math.log(2);
            var p = new MM.Point(0, 0);

            stderr('Zoom by ' + z.toFixed(3) + ' about ' + p.toString());
            stderr('Pan by ' + m[4].toFixed(0) + ', ' + m[5].toFixed(0));
            
            this.map.zoomByAbout(z, p);
            this.map.panBy(m[4], m[5]);
            this.map.parent.style.webkitTransform = '';
        }
        
        
        
        /*
        gestureStart: null,
        gestureChange: null,
        gestureCenter: null,
        gestureEnd: null,
        
        startCenter: null,
        startScale: undefined,
        startZoom: undefined,

        getGestureStart: function() {
            if (!this.gestureStart) {
                var theHandler = this;
                this.gestureStart = function(e) {
                    MM.addEvent(theHandler.map.parent, 'touchmove', theHandler.getGestureCenter());
                    MM.addEvent(theHandler.map.parent, 'gesturechange', theHandler.getGestureChange());            
                    MM.addEvent(theHandler.map.parent, 'gestureend', theHandler.getGestureEnd());            
                    theHandler.startScale = e.scale;
                    theHandler.startZoom = theHandler.map.getZoom();
                    return MM.cancelEvent(e);
                }
            }
            return this.gestureStart;
        },
        
        getGestureCenter: function() {
            if (!this.gestureCenter) {
                var theHandler = this;
                this.gestureCenter = function(e) {
                    if (e.touches.length == 2) {
                        var centerX = (e.touches[0].pageX + e.touches[1].pageX) / 2.0;
                        var centerY = (e.touches[0].pageY + e.touches[1].pageY) / 2.0;
                        theHandler.startCenter = new MM.Point(centerX, centerY);
                    }
                }
            }
            return this.gestureCenter;
        },

        getGestureChange: function() {
            if (!this.gestureChange) {
                var theHandler = this;
                this.gestureChange = function(e) {
                    if (theHandler.startScale !== undefined && theHandler.startZoom !== undefined) {
                        var scaleFactor = e.scale / theHandler.startScale;
                        var zoomFactor = Math.log(scaleFactor) / Math.log(2);
                        zoomFactor = Math.round(zoomFactor);
                        if (zoomFactor != 0 && theHandler.startCenter) {
                            var currentZoom = theHandler.map.getZoom();
                            var targetZoom = theHandler.startZoom + zoomFactor;
                            theHandler.map.zoomByAbout(targetZoom - currentZoom, theHandler.startCenter);
                        }
                    }
                    return MM.cancelEvent(e);
                }
            }
            return this.gestureChange;
        },
        
        getGestureEnd: function() {
            if (!this.gestureEnd) {
                var theHandler = this;
                this.gestureEnd = function(e) {
                    MM.removeEvent(theHandler.map.parent, 'gesturechange', theHandler.getGestureChange());            
                    MM.removeEvent(theHandler.map.parent, 'touchmove', theHandler.getGestureCenter());
                    MM.removeEvent(theHandler.map.parent, 'gestureend', theHandler.getGestureEnd());            
                    theHandler.startCenter = null;
                    theHandler.startScale = undefined;
                    theHandler.startZoom = undefined;
                    return MM.cancelEvent(e);
                }
            }
            return this.gestureEnd;
        },
        
        touchStartHandler: null,
    
        getTouchStart: function() {
            if (!this.touchStartHandler) {
                var theHandler = this;
                this.touchStartHandler = function(e) {
                    if (e.touches.length == 1) { 
                        MM.addEvent(document, 'touchcancel', theHandler.getTouchEnd());
                        MM.addEvent(document, 'touchend', theHandler.getTouchEnd());
                        MM.addEvent(document, 'touchmove', theHandler.getTouchMove());
                        theHandler.prevTouch = new MM.Point(e.changedTouches[0].pageX, e.changedTouches[0].pageY);
                    } 
                    return MM.cancelEvent(e);
                };
            }
            return this.touchStartHandler;
        },
        
        touchMoveHandler: null,
        
        getTouchMove: function() {
            if (!this.touchMoveHandler) {
                var theHandler = this;
                this.touchMoveHandler = function(e) {
                    if (theHandler.prevTouch && e.touches.length == 1) {
                        theHandler.map.panBy(e.touches[0].pageX - theHandler.prevTouch.x, 
                                             e.touches[0].pageY - theHandler.prevTouch.y);
                        theHandler.prevTouch.x = e.touches[0].pageX;
                        theHandler.prevTouch.y = e.touches[0].pageY;
                    }
                    return MM.cancelEvent(e);
                };
            }
            return this.touchMoveHandler;
        },
    
        touchEndHandler: null,
    
        getTouchEnd: function() {
            if (!this.touchEndHandler) {
                var theHandler = this;
                this.touchEndHandler = function(e) {
                    if (theHandler.prevTouch && e.touches.length == 0) {
                        MM.removeEvent(document, 'touchend', theHandler.getTouchEnd());
                        MM.removeEvent(document, 'touchcancel', theHandler.getTouchEnd());
                        MM.removeEvent(document, 'touchmove', theHandler.getTouchMove());
                        theHandler.prevTouch = null;
                    }
                    return MM.cancelEvent(e);
                };
            }
            return this.touchEndHandler;
        },
        
        doubleTapHandler: null,
    
        getDoubleTap: function() {
            if (!this.doubleTapHandler) {
                var theHandler = this,
                    prevPoint = null,
                    prevTime = 0;
                function distsq(p1,p2) {
                    var dx = p2.x-p1.x,
                        dy = p2.y-p1.y;
                    return dx*dx + dy*dy;
                }
                this.doubleTapHandler = function(e) {
                    if (e.touches.length == 1) {
                        var point = new MM.Point(e.touches[0].pageX, e.touches[0].pageY);
                        if (prevPoint) {
                            var dist = distsq(prevPoint, point),
                                dt   = new Date().getTime() - prevTime;
                            // TODO: find out what the "best" values for double tap tolerance are...
                            if (dist < 100.0 && dt < 400) {
                                theHandler.map.zoomByAbout(1, point);    
                            }
                        }
                        prevPoint = point;
                        prevTime = new Date().getTime(); 
                    }
                };
            }
            return this.doubleTapHandler;
        }
        */
    
    };

})(com.modestmaps);

var map;

function initMap() {

    var container = document.getElementById('container');

    map = new com.modestmaps.Map('map', 
                                 new com.modestmaps.TemplatedMapProvider('http://tile.openstreetmap.org/{Z}/{X}/{Y}.png'), 
                                 new com.modestmaps.Point(container.offsetWidth, container.offsetHeight),
                                 [ new com.modestmaps.TouchHandler() ]);

    map.setCenterZoom(new com.modestmaps.Location(37.811530, -122.2666097), 14);

    window.onresize = function() {
        map.setSize(container.offsetWidth, container.offsetHeight);
    };
    
    stderr('------------------------------------------------------------------------');
}

</script>
</head>
<body onload="initMap()" style="margin:0; padding:0; border:0">
<div id="container" style="width: 100%; height: 100%; -webkit-touch-callout: none; -webkit-user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0);">
  <div id="map">
  </div>
</div>
</body>
</html>
